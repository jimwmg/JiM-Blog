---
title:V8引擎处理事件队列的机制
date: 2017-12-22
categories: javascript
---

### 1 V8中队列简介

####1.1 javascript只有一个主线程，其他的是通过事件循环机制来实现异步的；

####**1.2 Macrotasks和Microtasks**

Macrotasks和Microtasks 都属于异步任务中的一种，他们分别有如下API：
**macrotasks:** script ,setTimeout, setInterval, setImmediate, I/O, UI rendering

其中从macroTask中取出任务的顺序如下：script > setTimeout > I/O > setImmediate 

**microtasks:** process.nextTick > Promise > MutationObserver

其中从microTasks中取出所有任务的执行顺序如下 process.nextTick > Promise

**这里需要注意的是，对于promise的链式调用，其实就是不断的向microTasks队列末尾添加任务，这些任务也会在本轮循环中执行；**

### 2 两种事件队列混合的时候执行顺序

* script标签中的代码先执行，从上到下
* 将microtasks中的任务**全部**取出，按顺序执行（对于promise的链式调用等也会实时追加进队列任务中）
* 从macroTasks中取出**下一个**，执行
* 在从microtasks中取出全部任务，按顺序执行
* 再从macrotasks中取出下一个，执行
* 如此循环，直到两个队列中的所有任务队列全部执行完毕

对于以上执行过程可以在进行总结成一轮一轮的事件循环：

* 从macrotasks中取出**一个**任务，执行 ；
* 从microtasks中取出**所有**任务，执行 ；

以上顺序循环往复，直到事件队列中没有任务,看一个最简单的例子

```javascript
setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
```

```javascript
macrotasks:[script:one,setTimeout:three]
microtasks:[promise:two]
```

**script:one ==> promise:two ==> setTimeout:three ==> 事件循环结束；**

script整体执行的时候，会将setTimeout的事件放入macrotasks, 将promise.then注册的事件放入microtasks中

整个循环其实就是：一个macrotasks ==> 全部 microtasks ==> 一个macrotasks ==> 全部 microtasks

### 3 实际案例分析下（node执行环境）

```javascript
console.log(0)

setTimeout(function(){
    console.log(2);
},0);
setImmediate(function(){
    console.log(1);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    setTimeout(function(){
        console.log(10)
    })
    console.log(5);
}).then(function(){
    console.log(6);
});
console.log(7);
process.nextTick(function(){
    console.log(8);
});
console.log(9);
//0 3 4 7 9 8 5 6 2 10 1

```

分析执行：

```javascript
macrotasks :[script(0,3,4,7,9),setTimeout:2 ,setImmediate:1,];
microtasks:[process.nextTick:8,promise:5];
```

* 自上而下执行script中的代码：0  3 4 7 9 

* 从microtasks中的**全部**任务取出来进行执行 ： 8 5 6 (其实在执行5的时候又向microtasks中添加了任务6，下面有例子会说明)

      此时microtasks:[ ]队列就为一个空数组，但是在执行的时候往macrotasks队列中添加了setTimeout:10,
        
      此时macrotasks:[setTimeout:2 ,setTimeout:10,setImmediate:1]

* 从macrotasks取出下一个任务执行 ：2 ；之后macrotasks:[setTimeout:10,setImmediate:1]

* 从microtasks队列中取出全部任务，此时任务队列为空，没有要执行的；

* 在从macrotasks取出下一个任务执行：10 ；之后macrotasks:[setTimeout:10]

* ………...循环往复

* 直到队列中所有的任务执行完毕；

###4 其余案例

**对于链式promise调用，第一个promsie resolve之后，后续如果then函数的promise自动会自动resolve,除非then函数中返回一个其他的promsie对象**

```javascript
console.log(0)

setTimeout(function(){
    console.log(2);
},0);
setImmediate(function(){
    console.log(1);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    setTimeout(function(){
        console.log(10)
    })
    console.log(5);
}).then(function(){
    console.log(6);
});
new Promise(function(resolve){
    console.log(33);
    resolve(); 
    console.log(44);
}).then(function(){
    setTimeout(function(){
        console.log(1010)
    })
    console.log(55);
}).then(function(){
    console.log(66);
});
console.log(7);
process.nextTick(function(){
    console.log(8);
});
console.log(9);
//0 3 4 33 44 7 9 8 5 55 6 66 2 10 1010 1
```

分析执行

```
macrotasks : [script(0,3,4,33,44,7,9),setTimeout:2 ,setImmediate:1];
microtasks:[process.nextTick:8,promise:5,55];
```

* (第一次循环)执行script任务 0，3，4，33，44，7，9; 执行process.nextTick 8 ,执行promise ,5 55 ;同时又向microtasks中添加了任务6 ，66 同样执行 ,并且加了macrotasks任务10, 1010

```
macrotasks : [setTimeout:2,setTimeout:10,setTimeout:1010 ,setImmediate:1];
microtasks:[];
```

* 第二次循环：执行setTimeout2 ,microtasks中没有要执行的任务
* 第三次循环：执行setTimeout10,microtasks中没有要执行的任务
* 第四次循环：执行setTimeout1010,microtasks中没有要执行的任务
* 第五次循环：执行setImmediate1 ,microtasks中没有要执行的任务；==>完毕

```javascript
console.log('start')

const interval = setInterval(() => {
  console.log('setInterval')
}, 0)

setTimeout(() => {
  console.log('setTimeout 1')
  Promise.resolve()
    .then(() => {
    console.log('promise 3')
  })
    .then(() => {
    console.log('promise 4')
  })
    .then(() => {
    setTimeout(() => {
      console.log('setTimeout 2')
      Promise.resolve()
        .then(() => {
        console.log('promise 5')
      })
        .then(() => {
        console.log('promise 6')
      })
        .then(() => {
        clearInterval(interval)
      })
    }, 0)
  })
}, 0)

Promise.resolve()
  .then(() => {
  console.log('promise 1')
})
  .then(() => {
  console.log('promise 2')
})

console.log('end')

```

```
start 
end
promise 1 
promise 2 
setInterval 
setTimeout 1 
promise 3 
promise 4 
setInterval 
setTimeout 2 
promise 5 
promise 6
```

```javascript
console.log(1);
new Promise((resolve,reject)=>{
  console.log(3);
  setTimeout(function(){console.log(8);resolve()},1000);
  console.log(4)
}).then(()=>{
  console.log(5)
  setTimeout(function(){console.log(7)},2000)
}).then(()=>{
  console.log(6)
})

console.log(2);
//1 3 4 2 8 5 6 7 
```

```javascript
async function asyncFunction1() {
    console.log('1 start');
    const result = await asyncFunction2(); // 将asyncFunction2返回的promsie放入事件队列中
    // 这里可以理解为两步：1 执行 asyncFunction2 函数等待其promise的resolve(注意，每个resolve之后的promise都是一个异步的调用)
    // 2 await让出js单线程，跳出asyncFunction1 函数，
    console.log('1 end');
    console.log('asyncFunction2 result',result)

  }
  async function asyncFunction2() {
    console.log('2 start');
    // 如果没有返回值，那么 await该函数，默认函数返回值是undefined;如果有返回值，那么await该函数的返回值就是其返回值；await 语句会将器后面的值直接resolve
  }
  // ok  开始
  console.log('0 script starts')
  setTimeout(function() {
    console.log('this is setTimeout');
  },0);
  asyncFunction1();
  new Promise((resolve,reject) => {
    console.log('3 promsie ');
    resolve();
  }).then(() => {
    console.log('4 promise');

  })
  console.log('5 script end ')
```

[案例](https://segmentfault.com/a/1190000015057278)

```
0 script starts
1 start
2 start
3 promsie 
5 script end 
4 promise
1 end
asyncFunction2 result undefined
this is setTimeout
```

```javascript
setTimeout(function(){console.log(1)},0);

new Promise(function(resolve,reject){
   console.log(2);
   setTimeout(function(){resolve()},0)
}).then(function(){console.log(3)
}).then(function(){console.log(4)});

process.nextTick(function(){console.log(5)});

console.log(6);
//2 6 5 1 3 4 
setTimeout(function(){console.log(1)},1000);

new Promise(function(resolve,reject){
   console.log(2);
   setTimeout(function(){resolve()},0)
}).then(function(){console.log(3)
}).then(function(){console.log(4)});

process.nextTick(function(){console.log(5)});

console.log(6);
//2 6 5 3 4 1 
```

