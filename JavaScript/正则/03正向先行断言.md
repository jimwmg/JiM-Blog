---
title: RegExp Review
date: 2017-12-12 12:36:00
categories: javascript 
---

### 1 环视的概念和基本用例

环视，在不同的地方又称之为零宽断言，简称断言。 
环视强调的是它所在的位置，前面或者后面，必须满足环视表达式中的匹配情况，才能匹配成功。 
环视可以认为是虚拟加入到它所在位置的附加判断条件，并不消耗正则的匹配字符。

* 简单的环视匹配过程,先看下面这个例子

```javascript
//案例1
var reg = /(?=B)/g; // ?=B 表示字母B 前面的位置
var str = 'ABCFDBE';
var ret = str.replace(reg,'#');
console.log(ret);//A#BCFD#BE
//案例2 
var reg1 = /(?=B)C/g; //相当于匹配
var ret1 = str.replace(reg1,'#');
console.log(ret1);//ABCFDBE
//案例3
var reg2 = /(?=B)B/g;
var ret2 = str.replace(reg2,'#');
console.log(ret2);//A#CFD#E
```

— 首先要明白(?=p)匹配的是一个位置，即表达式 p前面的位置（位置包括开头^ 结束 $ \B \b）

—其次要明白正则匹配的过程

##### 1.1 对于案例1的匹配过程.    源字符串 'ABCFDBE'   正则  /(?=B)/g ;

先从字符串的开始位置，也就是正则中的 `^`位置处开始匹配，该位置后面是 'A',匹配失败；

=>然后从 'A' 和 'B'之间的位置再次匹配，该位置后面是 B ,匹配到该位置，将该位置替换为 '#'

=>再从 'B'和 'C'之间的位置再次匹配，该位置后面是C，匹配失败，继续后移 。。。。

##### 1.2 对于案例2 的匹配过程。  源字符串 'ABCFDBE'.  正则 /(?=B)C/g;

先从字符串的开始位置，也就是正则中的 `^`位置处开始匹配，该位置后面是 'A',匹配失败，后移一位；

=>然后从 'A' 和 'B'之间的位置再次匹配，该位置后面是 B ,匹配到该位置，正则中的C去匹配源字符串该位置后面的B，匹配失败，后移一位；

=>再从 'B'和 'C'之间的位置再次匹配，该位置后面是C，匹配失败，继续后移 。。。。

最后没有匹配到的结果；

##### 1.3 对于案例3 的匹配过程。 源字符串 'ABCFDBE'. 正则 /(?=B)B/g

先从字符串的开始位置，也就是正则中的 `^`位置处开始匹配，该位置后面是 'A',匹配失败；

=>然后从 'A' 和 'B'之间的位置再次匹配，该位置后面是 B ,匹配到该位置，正则中的B去匹配源字符串该位置后面的B，匹配成功，后移一位；

=>再从 'B'和 'C'之间的位置再次匹配，该位置后面是C，匹配失败，继续后移 。。。。

**对于（?=p）的匹配，有两种理解方式：第一就是该正则不消耗源字符串，第二就是该正则其实是消耗源字符串中的位置**

或者说先行断言会先检查字符串是否有符合条件的那个位置，如果有，那么从那个位置开始真正的匹配字符串；

### 2 看一个验证密码问题

* 密码长度 6-12位，由数字，大写字母，小写字母组成
* 至少包含数字和字母（不区分大小写）

问题解决思路

#####  2.1 先写一个密码长度 6-12位，由数字，大写字母，小写字母组成的正则 

```javascript
var str = 'abcd9efg';
var reg = /^[a-zA-Z0-9]{6,12}$/;
console.log(str.match(reg));
//["abcd9efg", index: 0, input: "abcd9efg"]
```

##### 2.2 至少一个包含数字（不区分大小写）

```javascript
var reg = /^(?=.*[0-9])[a-zA-Z0-9]{6,12}$/;//or 
var reg = /^(?=.*?[0-9])[a-zA-Z0-9]{6,12}$/;//无论贪婪匹配还是惰性匹配都是可以的 *(贪婪) *?(非贪婪)
var reg = /(?=.*?[0-9])^[a-zA-Z0-9]{6,12}$/;//或者这么，位置匹配可以理解为字符串中可以有很多位置，这些位置都是空字符；
```

对于这个正则我们如何理解呢？

对于源字符串 'abcd9efg' ，正则  `/^(?=.*?[0-9])[a-zA-Z0-9]{6,12}$/`;中

 ^ 匹配源字符串开始的位置，

` (?=.*[0-9])` 匹配 ^ 和字符a之间的位置，对于这个位置要求是该位置后面的字符需要满足   `.*[0-9]` 	这个正则的匹配

```javascript
var str = 'abcd9efg';
var reg1= /^(?=abc[0-9])[a-zA-Z0-9]{6,12}$/;  
console.log(str.match(reg1));  // null
console.log(/(?=abc[0-9])/.test(str)) ;//false  
var reg2= /^(?=abcd[0-9])[a-zA-Z0-9]{6,12}$/;    
console.log(str.match(reg2));  //["abcd9efg", index: 0, input: "abcd9efg"]
console.log(/(?=abcd[0-9])/.test(str)) ;//true
```

##### 2.3 至少包含一个字母(不区分大小写)

```javascript
var reg = /^(?=.*[a-zA-Z])[a-zA-Z0-9]{6,12}$/;
var reg = /^(?=.*[a-zA-Z])[a-zA-Z0-9]{6,12}/;
var reg = /(?=.*[a-zA-Z])^[a-zA-Z0-9]{6,12}/;
```

```javascript
var reg3 = /^(?=[a-z])[a-zA-Z0-9]{6,12}/;
console.log(str.match(reg3));  //["abcd9efg", index: 0, input: "abcd9efg"]
console.log(/(?=[a-z])/.test(str)) ;//true
```

##### 2.4 结合起来就是

```javascript
var reg = /^(?=.*[a-zA-Z](?=.*[0-9]))[a-zA-Z0-9]{6,12}/;
```

这个在理解的时候，可以说在开始位置 ^ 和 源字符串首字母之间有很多个位置，对这些位置进行限制即可；

##### 2.5 改一下要求，至少包含数字，大写字母，小写字母三者中的两个

```javascript
var reg = /^((?=.*[a-z])(?=.*[A-Z])|(?=.*[A-Z])(?=.*[0-9])|(?=.*[a-z])(?=.*[0-9]))[0-9a-zA-Z]{6,12}/
```

另外一种实现思路，就是至少包含两种字符，就是不能全是某一种字符

```javascript
var reg = /^(?![a-z]{6,12})(?![A-Z]{6,12})(?![0-9]{6,12})[0-9a-zA-Z]{6,12}/
```

#### 2.6 数字，英文，特殊符号，至少包含其中两个 8-20位

```javascript
var reg = /^(?![a-zA-Z]{8,20})(?![0-9]{8-20})(?![特殊字符]{8,20})[0-9A-Za-z特殊字符]{8,20}/
```

