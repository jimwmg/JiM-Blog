---
title:数据结构-堆
---

### 1 堆

**堆数据结构也是一种数组对象，他可以被视为一个完全二叉树结构，所以堆也叫做二叉堆**

二叉堆满足两个特性： 

* 父节点的键值总是大于或者等于（小于或者等于）任何一个字节点的键值

* 每个节点的左子树和右子树都是一个二叉树 ( 二叉树是一种特殊的树，二叉树的每个节点最多只能有2个子节点)


**当父节点的键值总是大于或者等于子节点的键值时，称为最大堆；当父节点的键值总是小于或者等于子节点 的键值的时候，称为最小堆**

### 2 堆的数据结构可以理解为二叉树的形状（纯数学的角度，就是每一层树中有 2^n 个节点 n = 0,1,2,3 ...)

最后生成一个树状（金字塔）形式的数据结构；

* 二叉树：从一个根节点开始，每个节点连接一到**两个子节点**，一次向下展开的树形结构，叫做二叉树；
* 满二叉树：在二叉树的基础上，除了最后一层节点没有任何子节点外，每一层节点都有两个子节点，且每一层都完全填满的二叉树，叫做满二叉树。（从深度和节点关系数上来看，一颗深度为k的二叉树，有 2^k - 1 个节点）
* 完全二叉树：**这个概念需要重点理解下，第一，假如我们队满二叉树从左至右进行编号（具体的编号规则可以自定），如果同样一个深度为k,有n个节点的二叉树，其每个节点和深度同为k的满二叉树，在同样的编号规则下一一对应的话，那么这棵树就是完全二叉树**（另外一种理解方式：若设二叉树的高度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层**从右向左**连续缺若干结点，就是完全二叉树。也就是说如果一个结点有右子结点，那么它一定也有左子结点）

作为对比， 看看下图中左下角和右下角的两颗树， 因为按照满二叉树的编号排定方式，它们**相比起同深度的满二叉树而言， 分别在6和3的位置没有对应的节点，所以不是完全二叉树**

![binaryTree](/myWork/JiM-Blog/img/binaryTree.png)

### 3 堆有序

对于一个二叉树：如果他满足(对于数组表示的堆有序来说，最终比较的是数组中的每个元素的值之间的大小)

* 任意一个父节点都小于等于它相邻的所有子节点
* 任意一个父节点都大于等于它相邻的所有子节点

这两种情况可以称为堆有序（注意和二叉搜索树的不同，二叉搜索树需要满足的条件是：只允许节点有两个子节点，且左侧存储比父节点小的值，右侧存储比父节点大的值）

**对于堆有序的完全二叉树，就叫做二叉堆；**二叉堆的表示方法可以用一个普通的一维数组来表示；

![duiyouxu](/myWork/JiM-Blog/img/duiyouxu.png)

### 4 二叉堆的数组表示

![array_erchadui ](/myWork/JiM-Blog/img/array_erchadui .png)

二叉堆可以用一个普通的一维数组来表示，按照从上至下，从左至右的编号，把二叉堆节点从0 至 N-1进行编号，并以此作为数组的下标，放入一个长度为 N的数组中，那么就形成了一个用数组表示的二叉堆；

在一个二叉堆中，位置为 k 的节点的父节点的位置是 `Math.floor(k/2)`,而两个子节点的位置分别是 `2k 和 2k+1`.这样的话，在该二叉堆对应的数组中，我们就可以通过计算数组的下标在堆中上下移动；通过这层数字关系，我们就可以找到任意一个堆中节点的父节点和子节点，并进行比较，在这层基础上，我们就可以来设计我们的堆有序算法了；

#### 4.1 堆排序的基本算法：上浮和下沉；

堆排序的核心就是堆有序化的算法；

```javascript

```









[参考](https://zhuanlan.zhihu.com/p/31440467?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=557638542403112960)