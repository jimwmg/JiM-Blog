---

---

### 1 npm semver version

首先了解 npm 语义化版本号

版本号一般有三个部分，以`.`隔开，就像`X.Y.Z`，其中

- X：主版本号，不兼容的大改动
- Y：次版本号，功能性的改动
- Z：修订版本号，问题修复

对于 `^  ~ ` 等所代表的那些版本，具体可以参考 [npm semver calculator](https://semver.npmjs.com/)

```
npm i pkg   //会安装最新版本，如果package.json中有对应的版本范围，则安装改范围内的最新版本
npm i pkg@version  //安装指定版本
```

### 2 npm 安装的时候，版本是如何固化的？

npm 5.0.x 版本：不管 package.json 中依赖是否有更新，npm i 都会根据 package-lock.json 下载。针对这种安装策略，有人提出了这个 issue -  [#16866](https://github.com/npm/npm/issues/16866) ，然后就演变成了 5.1.0 版本后的规则。

5.1.0 版本后：当 package.json 中的依赖项有新版本时，npm install 会无视 package-lock.json 去下载新版本的依赖项并且更新 package-lock.json。针对这种安装策略，又有人提出了一个 issue - [#17979](https://github.com/npm/npm/issues/17979) ，参考 npm 贡献者 iarna 的评论，得出 5.4.2 版本后的规则。

5.4.2 版本后：

场景一：只有一个 package.json 文件，没有任何依赖项，运行 npm i  pkg@version 安装固定的版本，npm 会根据这个生成 package-lock.json 文件

场景二：如果只有一个 package.json 文件，该文件中有 dependencies 依赖项，运行 `npm i` 会根据它生成一个 package-lock.json 文件。

场景三：如果 package.json 的 semver-range version 和 package-lock.json 中版本兼容，即使此时 package.json 中有新的版本，执行 `npm i` 也还是会根据 package-lock.json 下载 -。

场景四：如果手动修改了 package.json 的 version ranges，且和 package-lock.json 中版本不兼容，那么执行 `npm i` 时 package-lock.json 将会更新到兼容 package.json 的版本 

场景五：不同 node 版本下，安装 指定版本生成的 package-lock.json 文件的区别；

### 3 开始测试

```
node 版本 8.10.0
npm 版本 5.6.0
```

**新建一个文件夹，git  init  ，方便对比文件变更**

添加 `.gitignore`

```javascript
node_modules/
```

初始文件夹目录如下

```javascript
--npm-semver-learn
	-- .gitignore
  -- package.json
```

以 superagent 这个 npm 包为例，在[npm semver calculator](https://semver.npmjs.com/) 上输入这个包即可查看该包相关的 版本信息；

#### 场景一：

初始化一个 package.json ,假如内容如下

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
  }
}
```

执行  npm i pkg@version   会安装固定的版本；

```
npm i superagent@3.5.1
```

#### 查看 package.json

```java
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
    "superagent": "^3.5.1"
  }
}

```

#### 查看 package-lock.json,可以看到关于 superagent 这个包相关的固化的信息；

```json
 "superagent": {
      "version": "3.5.1",
      "resolved": "https://registry.npmjs.org/superagent/-/superagent-3.5.1.tgz",
      "integrity": "sha1-Ck+u/aM2d3d4iDR917TSH0EMhxs=",
      "requires": {
        "component-emitter": "1.3.0",
        "cookiejar": "2.1.2",
        "debug": "2.6.9",
        "extend": "3.0.2",
        "form-data": "2.5.1",
        "formidable": "1.2.1",
        "methods": "1.1.2",
        "mime": "1.6.0",
        "qs": "6.9.1",
        "readable-stream": "2.3.6"
      }
    },
```

#### 查看 node_modules/superagent 中的 package.json 中的关键字段

上面 package-lock.json 中的 requires 字段所安装的 npm 包的版本也是根据 下面的 dependencies 字段的版本范围安装的最大版本；注意这个场景，下面回合场景五进行对比；不同之处在于  requires  字段；

```json
"_from": "superagent@3.5.1",
"_id": "superagent@3.5.1",
"version": "3.5.1"
"dependencies": {
    "component-emitter": "^1.2.0",
    "cookiejar": "^2.0.6",
    "debug": "^2.2.0",
    "extend": "^3.0.0",
    "form-data": "^2.1.1",
    "formidable": "^1.1.1",
    "methods": "^1.1.1",
    "mime": "^1.3.4",
    "qs": "^6.1.0",
    "readable-stream": "^2.0.5"
  },
```

**可以看到  npm i  pkg@version 固化的版本就是安装的具体版本；**

执行 

```
git add .
git commit -m'场景一'
```

将 package.json 和 package-lock.json 的变更提交，方便对于下次的更改作对比；

**此时如果删除 node_modules 然后在执行 `npm i ` 发现安装的版本还是  3.5.1，而不是 3.8.3，可以看到，版本是被固化了的；此时验证了场景三，如果 package.json 的 semver-range version 和 package-lock.json 中版本兼容，即使此时 package.json 中有新的版本，执行 `npm i` 也还是会根据 package-lock.json 下载；因为理论上"superagent": "^3.5.1" 在执行 npm i的时候，理论上是应该安装 3.8.3 版本的 **

#### 场景二

假如此时只有一个 package.json 文件,有 dependencies 相关依赖项，如下

其实也就是将场景一的 node_modules 和 package-lock.json 删除；

```json
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
    "superagent": "^3.5.1"
  }
}
```

此时执行

```
npm i 
```

查看 package-lock.json ,观察对于 superagent 的固化信息

```json
"superagent": {
      "version": "3.8.3",//这里
      "resolved": "https://registry.npmjs.org/superagent/-/superagent-3.8.3.tgz",
      "integrity": "sha512-GLQtLMCoEIK4eDv6OGtkOoSMt3D+oq0y3dsxMuYuDvaNUvuT8eFBuLmfR0iYYzHC1e8hpzC6ZsxbuP6DIalMFA==",
      "requires": {
        "component-emitter": "1.3.0",
        "cookiejar": "2.1.2",
        "debug": "3.2.6",//这里
        "extend": "3.0.2",
        "form-data": "2.5.1",
        "formidable": "1.2.1",
        "methods": "1.1.2",
        "mime": "1.6.0",
        "qs": "6.9.1",
        "readable-stream": "2.3.6"
      }
    },
```

对比可以发现 `superagent debug` 这两个版本不一样了；究其原因 package.json 中,superagent的版本如下

```json
"superagent": "^3.5.1"
```

当我们执行  `npm i `的时候，npm 会根据 [npm semver calculator](https://semver.npmjs.com/) 计算出来的版本范围，安装最新的版本，即3.8.3，

而 3.8.3 依赖的 debug 版本也是变化了的；

查看 node_modules/superagent 中的 package.json

```json
"_from": "superagent@^3.5.1",
"_id": "superagent@3.8.3",
"dependencies": {
    "component-emitter": "^1.2.0",
    "cookiejar": "^2.1.0",
    "debug": "^3.1.0",
    "extend": "^3.0.0",
    "form-data": "^2.3.1",
    "formidable": "^1.2.0",
    "methods": "^1.1.1",
    "mime": "^1.4.1",
    "qs": "^6.5.1",
    "readable-stream": "^2.3.5"
  },
  "version": "3.8.3"
```

注意了：

##### 正常来说，如果npm 包的管理者在发布次版本号的 npm 新包的时候，比如 3.5.1 和 3.8.3 ，按照规则来说，是应该兼容的；但是！ 假如npm 包管理者没有按照规则来，在 3.8.3 发布了不兼容的内容，那么此时问题就来了，因为没有 package-lock.json, 导致安装的是 3.8.3 版本，而不是3.5.1，那么此时就会有问题！！！

这种 case 经常发生的情况是这样的，假如 同事A，新建了一个仓库，安装了  `npm i superagent@3.5.1`,此时生成的 package-lock.json  将 superagent 锁定在 3.5.1 这个版本，但是他没有上传该文件，而同事 B 在下载下来这个仓库之后，直接在终端执行  `npm i `,此时会生成新的 package-lock.json 文件，而这个新的 lock文件是将 superagent 锁定在 3.8.3 这个版本；而如果  superagent 的发布者在 3.5.1 到 3.8.3 发布了不兼容的内容，那么此时就是一个巨大的隐患了；

##### Tips：如果仅仅将  package-lock.json 文件删除，而不删除 node_modules ,那么 执行 npm i 之后，生成的 package-lock.json  还是和原来的一样 ，node_modules 也和原来的一样；



#### 场景三在场景一已经复现过

#### 场景四:如果手动修改了 package.json 的 version ranges，且和 package-lock.json 中版本不兼容，那么执行 `npm i` 时 package-lock.json 将会更新到兼容 package.json 的版本 -

在场景一或者场景二的情况下；

即存在 package-lock.json  锁定了 superagent 的版本为 3.5.1 或者 3.8.3

此时手动修改 package.json   superagent 的版本号 为 ^5.1.0,如下

（如果改成 "superagent": "^2.0.0" 则会安装 2.3.0）

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
    "superagent": "^5.1.0"
  }
}
```

然后执行 `npm i`

查看 pacage-lock.json

```javascript
"superagent": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/superagent/-/superagent-5.1.0.tgz",
      "integrity": "sha512-7V6JVx5N+eTL1MMqRBX0v0bG04UjrjAvvZJTF/VDH/SH2GjSLqlrcYepFlpTrXpm37aSY6h3GGVWGxXl/98TKA==",
      "requires": {
        "component-emitter": "1.3.0",
        "cookiejar": "2.1.2",
        "debug": "4.1.1",
        "fast-safe-stringify": "2.0.7",
        "form-data": "2.5.1",
        "formidable": "1.2.1",
        "methods": "1.1.2",
        "mime": "2.4.4",
        "qs": "6.9.1",
        "readable-stream": "3.4.0",
        "semver": "6.3.0"
      }
    },
```

- **只要 package-lock.json 中的   ##版本号##  和 package.json 中的  ##版本号范围## 不兼容，那么就以package.json 中的  ##版本号范围最新版本##  进行安装;**

- **如果 package-lock.json中的 ##版本号##  和 package.json 中的  ##版本号范围## 兼容，那么就会以 package-lock.json 中的 ## 版本号## 进行安装**

#### 场景五：不同 node 版本下，安装 指定版本生成的 package-lock.json 文件的区别；

在场景一的情况下，切换node 版本 执行 npm i 

```
nvm use 11.7
node -v //11.7
npm -v //6.5.0
```

然后执行 `npm i`

查看 package-lock.json

```javascript
"superagent": {
      "version": "3.5.1",
      "resolved": "https://registry.npmjs.org/superagent/-/superagent-3.5.1.tgz",
      "integrity": "sha1-Ck+u/aM2d3d4iDR917TSH0EMhxs=",
      "requires": {
        "component-emitter": "^1.2.0",
        "cookiejar": "^2.0.6",
        "debug": "^2.2.0",
        "extend": "^3.0.0",
        "form-data": "^2.1.1",
        "formidable": "^1.1.1",
        "methods": "^1.1.1",
        "mime": "^1.3.4",
        "qs": "^6.1.0",
        "readable-stream": "^2.0.5"
      }
    },
```

查看 node_modules/superagent 中的 package.json

```javascript
"dependencies": {
    "component-emitter": "^1.2.0",
    "cookiejar": "^2.0.6",
    "debug": "^2.2.0",
    "extend": "^3.0.0",
    "form-data": "^2.1.1",
    "formidable": "^1.1.1",
    "methods": "^1.1.1",
    "mime": "^1.3.4",
    "qs": "^6.1.0",
    "readable-stream": "^2.0.5"
  },
```

可以看到生成的 package-lock.json 的 requires 就是 dependencies ，而没有自动改成对应的具体的版本号；

如果同时之间在开发功能的时候使用的不同的 node 版本，这个些许细微的差异还是要注意下；

### 4 如果 安装了两个 npm 包，而这两个 npm 包共同依赖一个 npm 包，但是版本不一致，这个问题会出现怎样的现象呢？

首先我们制造两个符合要求的 npm 包

`lerna-tool1@2.0.0  `  依赖 lodash ^3.8.0

```javascript
{
  "name": "lerna-tool1",
  "version": "2.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^3.8.0"
  },
  "gitHead": "eeabc0704fe0f20698403eb31a7e27074339dd10"
}

```

`lerna-tool2@2.0.0`  依赖 ^4.2.0

```javascript
{
  "name": "lerna-tool2",
  "version": "2.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.2.0"
  },
  "gitHead": "eeabc0704fe0f20698403eb31a7e27074339dd10"
}
```

#### 版本信息

```
node 8.10.0
npm 5.6.0
```

#### 场景一：先安装 lerna-tool1@2.0.0(依赖lodash:^3.8.0) ,在安装 lerna-tool2@2.0.0(依赖 lodash:^4.2.0)

初始化 package.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
  }
}
```

执行 `npm install lerna-tool1@2.0.0`

查看生成 package-lock.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lerna-tool1": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool1/-/lerna-tool1-2.0.0.tgz",
      "integrity": "sha512-K9Nx3Xy4LMPaRWfR6FNzX7Fgg3ztuhzMqQunb0Q8vsH4ciF7AlC99DJFmYQTRlZtAmye9nC7Xe0rv1EC8R5I5Q==",
      "requires": {
        "lodash": "3.10.1"
      }
    },
    "lodash": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-3.10.1.tgz",
      "integrity": "sha1-W/Rejkm6QYnhfUgnid/RW9FAt7Y="
    }
  }
}

```

查看 node_modules 里面的安装结构

然后执行 `npm i lerna-tool2@2.0.0`

查看改变后的 package-lock.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lerna-tool1": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool1/-/lerna-tool1-2.0.0.tgz",
      "integrity": "sha512-K9Nx3Xy4LMPaRWfR6FNzX7Fgg3ztuhzMqQunb0Q8vsH4ciF7AlC99DJFmYQTRlZtAmye9nC7Xe0rv1EC8R5I5Q==",
      "requires": {
        "lodash": "3.10.1"
      }
    },
    "lerna-tool2": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool2/-/lerna-tool2-2.0.0.tgz",
      "integrity": "sha512-+lKzKtmEaCPAHEnQPziwsvSuZlVNusxFgT/KOe4AAbufxmjR8agZN6y/Kb/Buz2H4/2IHkYPMFUx78deXcxD/w==",
      "requires": {
        "lodash": "4.17.15"
      },
      "dependencies": {
        "lodash": {
          "version": "4.17.15",
          "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.15.tgz",
          "integrity": "sha512-8xOcRHvCjnocdS5cpwXQXVzmmh5e5+saE2QGoeQmbKmRS6J3VQppPOIt0MnmE+4xlZoumy0GPG0D0MVIQbNA1A=="
        }
      }
    },
    "lodash": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-3.10.1.tgz",
      "integrity": "sha1-W/Rejkm6QYnhfUgnid/RW9FAt7Y="
    }
  }
}

```

在查看 node_modules 目录,因为 lerna-tool1 依赖的是lodash 3.x.x的版本，而 lerna-tool2 依赖的是lodash 4.x.x 的版本，所以在安装 的时候 lerna-tool2 依赖的 lodash 4.x.x 不能被扁平化出来；

删除 node_modules 发现安装的依赖还是一样的；

#### 场景二：先安装 lerna-tool2@2.0.0(依赖lodash:^4.2.0) ,在安装 lerna-tool1@2.0.0(依赖 lodash:^3.8.0)

初始化 package.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
  }
}
```

执行 `npm i lerna-tool2@2.0.0`

查看生成 package-lock.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lerna-tool2": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool2/-/lerna-tool2-2.0.0.tgz",
      "integrity": "sha512-+lKzKtmEaCPAHEnQPziwsvSuZlVNusxFgT/KOe4AAbufxmjR8agZN6y/Kb/Buz2H4/2IHkYPMFUx78deXcxD/w==",
      "requires": {
        "lodash": "4.17.15"
      }
    },
    "lodash": {
      "version": "4.17.15",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.15.tgz",
      "integrity": "sha512-8xOcRHvCjnocdS5cpwXQXVzmmh5e5+saE2QGoeQmbKmRS6J3VQppPOIt0MnmE+4xlZoumy0GPG0D0MVIQbNA1A=="
    }
  }
}

```

注意查看 node_modules 目录结构

然后在执行 `npm i lerna-tool1@2.0.0`

查看package-lock.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lerna-tool1": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool1/-/lerna-tool1-2.0.0.tgz",
      "integrity": "sha512-K9Nx3Xy4LMPaRWfR6FNzX7Fgg3ztuhzMqQunb0Q8vsH4ciF7AlC99DJFmYQTRlZtAmye9nC7Xe0rv1EC8R5I5Q==",
      "requires": {
        "lodash": "3.10.1"
      },
      "dependencies": {
        "lodash": {
          "version": "3.10.1",
          "resolved": "https://registry.npmjs.org/lodash/-/lodash-3.10.1.tgz",
          "integrity": "sha1-W/Rejkm6QYnhfUgnid/RW9FAt7Y="
        }
      }
    },
    "lerna-tool2": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool2/-/lerna-tool2-2.0.0.tgz",
      "integrity": "sha512-+lKzKtmEaCPAHEnQPziwsvSuZlVNusxFgT/KOe4AAbufxmjR8agZN6y/Kb/Buz2H4/2IHkYPMFUx78deXcxD/w==",
      "requires": {
        "lodash": "4.17.15"
      }
    },
    "lodash": {
      "version": "4.17.15",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.15.tgz",
      "integrity": "sha512-8xOcRHvCjnocdS5cpwXQXVzmmh5e5+saE2QGoeQmbKmRS6J3VQppPOIt0MnmE+4xlZoumy0GPG0D0MVIQbNA1A=="
    }
  }
}

```

在查看 node_modules 目录,因为 lerna-tool2 依赖的是lodash 4.x.x的版本，而 lerna-tool1 依赖的是lodash 3.x.x 的版本，所以在安装 的时候 lerna-tool1 依赖的 lodash 3.x.x不能被扁平化出来；

以上场景一和场景二在切换到 `node 11.7  npm 6.5 `结果也是一样的；

#### 场景三：

比如初始化以下 package.json

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "scripts": {},
  "license": "MIT",
  "dependencies": {
    "lerna-tool1": "^2.0.0",
    "lerna-tool2": "^2.0.0",
    "lerna-tool3": "^2.0.0"
  }
}
```

查看生成的 package-lock.json 

```javascript
{
  "name": "package-npm-test",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lerna-tool1": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool1/-/lerna-tool1-2.0.0.tgz",
      "integrity": "sha512-K9Nx3Xy4LMPaRWfR6FNzX7Fgg3ztuhzMqQunb0Q8vsH4ciF7AlC99DJFmYQTRlZtAmye9nC7Xe0rv1EC8R5I5Q==",
      "requires": {
        "lodash": "3.10.1"
      }
    },
    "lerna-tool2": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool2/-/lerna-tool2-2.0.0.tgz",
      "integrity": "sha512-+lKzKtmEaCPAHEnQPziwsvSuZlVNusxFgT/KOe4AAbufxmjR8agZN6y/Kb/Buz2H4/2IHkYPMFUx78deXcxD/w==",
      "requires": {
        "lodash": "4.17.15"
      },
      "dependencies": {
        "lodash": {
          "version": "4.17.15",
          "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.15.tgz",
          "integrity": "sha512-8xOcRHvCjnocdS5cpwXQXVzmmh5e5+saE2QGoeQmbKmRS6J3VQppPOIt0MnmE+4xlZoumy0GPG0D0MVIQbNA1A=="
        }
      }
    },
    "lerna-tool3": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lerna-tool3/-/lerna-tool3-2.0.0.tgz",
      "integrity": "sha512-hC20eKP2FBqbNMHHiTcmUVFcCIwTk3etP1Te0NvYlf2DwuDSBAaijw93LKSD+xnabuhT02m9+lcOKROYJN2qfw==",
      "requires": {
        "lodash": "2.0.0"
      },
      "dependencies": {
        "lodash": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/lodash/-/lodash-2.0.0.tgz",
          "integrity": "sha1-nc+eP6wErQo4yeLbacn7fOJtq8I="
        }
      }
    },
    "lodash": {
      "version": "3.10.1",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-3.10.1.tgz",
      "integrity": "sha1-W/Rejkm6QYnhfUgnid/RW9FAt7Y="
    }
  }
}
```

### 5 npm-shrinkwrap.json 和 package-lock.json 的关联和区别

[npm上关于 npm-shrinkwrap.json的解释](https://www.npmjs.cn/files/shrinkwrap.json/)

[npm 上关于 package-lock.json 的解释](https://www.npmjs.cn/files/package-lock.json/)

package-lock.json 是在执行 npm i 的时候自动生成的，如果要发布npm 包，package-lock.json 是不会被发布到 npm 上的；

npm-shrinkwrap.json 是通过 npm shrinkwrap 这个命令生成的，如果要发布npm包，这个文件是会被发布到 npm 上的；

**一般建议npm 包的发布者不要将 npm-shrinkwrap.json 发布到npm 上的，因为这个包依赖的其他包并不会被npm 扁平化处理；这个文件一般在发布终端命令行的时候才会用**

#### 从npm处理机制来看

1. 在一个项目里，如果本身不存在这两个文件，那么在运行`npm install`时，会自动生成一个`package-lock.json`，或者在初始化一个项目`npm init`时，也会生成`package-lock.json`，安装信息会依据该文件进行，而不是单纯按照`package.json`，这两个文件的优先级都比`package.json`高
2. 如果项目两个文件都存在，那么安装的依赖是依据`npm-shrinkwrap.json`来的，而忽略`package-lock.json`
3. 运行命令`npm shrinkwrap`后，如果项目里不存在`package-lock.json`，那么会新建一个`npm-shrinkwrap.json`文件，如果存在`package-lock.json`，那么会把`package-lock.json`重命名为`npm-shrinkwrap.json`

#### 从文件更新来看

1. `npm-shrinkwrap.json`只会在运行`npm shrinkwrap`才会创建/更新
2. `package-lock.json`会在修改pacakge.json或者node_modules时就会自动产生或更新了。

#### 从发布包来看

1. `package-lock.json`不会在发布包中出现，就算出现了，也会遭到npm的无视。
2. `npm-shrinkwrap.json`可以在发布包中出现

