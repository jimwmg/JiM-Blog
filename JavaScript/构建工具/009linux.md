---
title: linux
---

* 查看当前mac下JDK

```
打开终端：/usr/libexec/java_home -V（V必须大写）

1.8.0_131, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home
/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home

以上输出分别表示：输入命令； 当前Mac已安装jdk目录； Mac默认使用的jdk版本；
```

### 1 目录相关操作(列表 ，移动，删除，复制等)

* ls  列出当前目录

```
-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)   ls -a
-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)           ls-d
-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)			ls-l
```

* Linux系统中使用以下命令来查看文件的内容：

```
- cat  由第一行开始显示文件内容
- tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！
- nl   显示的时候，顺道输出行号！
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
- head 只看头几行
- tail 只看尾巴几行
```

* Linux系统中编辑文件内容. 

```
touch filename 可以用来创建一个文件名
命令模式   <—ESC————i a s —>输入模式     
命令模式   <-ESC ———— : > 底线命令模式 
```

* who 可以用来看终端的个数；
* which: 可以查看某个命令所在的位置，通过该位置可以看具体的详细信息；
* pwd: 打印出当前所在目录
* mkdir ： 新建一个目录
* rmdir : 删除一个目录；
* cd: 进入某一级目录；
* rm 删除一个文件(注意只有在提供 -r 选项的时候，才可以删除目录)，-f 强制删除一个文件(删除一个不存在的文件加这个选项不会报错)  -i 用户删除文件的时候回有一个提示 ; rm -rf
* cp 可以用来copy一个文件，`cp [选项][ 来源文件 ] [目的文件] `选项 -r 可以用来copy目录， -i 有一个提示 -u 仅当目标文件存在才会考虑
* mv :` mv [选项][来源文件][目的文件]`  可以用来重命名目录: mv  ./README.md  ./new.md重命名当前目录下的README.md为 new.md，内容不变；
* redir: 删除一个目录,不能删除一个文件
* alias：用于设置一个命令的别名
* whoami: 显示用户名（didi）
* clear: 清空终端所有的内容

### 2 shell脚本 && 环境变量

概念： 简单点理解，就是系统跟计算机硬件交互时使用的中间介质，它只是系统的一个工具。实际上，在shell和计算机硬件之间还有一层东西那就是系统内核了。打个比方，如果把计算机硬件比作一个人的躯体，而系统内核则是人的大脑，至于shell，把它比作人的五官似乎更加贴切些。回到计算机上来，用户直接面对的不是计算机硬件而是shell，用户把指令告诉shell，然后shell再传输给系统内核，接着内核再去支配计算机硬件去执行各种操作。

上边提到了alias，也提到了绝对路径的/bin/rm ，然后你意识到没有，为什么我们输入很多命令时是直接打出了命令，而没有去使用这些命令的绝对路径？这是因为环境变量PATH在起作用了。请输入 echo $PATH，这里的echo其实就是打印的

意思，而PATH前面的$表示后面接的是变量。

首先它是一个脚本，并不能作为正式的编程语言。因为是跑在linux的shell中，所以叫shell脚本。说白了，shell脚本就是一些命令的集合。举个例子，我想实现这样的操作：1）进入到/tmp/目录；2）列出当前目录中所有的文件名；3）把所有当前的文件拷贝到/root/目录下；4）删除当前目录下所有的文件。简单的4步在shell窗口中需要你敲4次命令，按4次回车。这样是不是很麻烦？当然这4步操作非常简单，如果是更加复杂的命令设置需要几十次操作呢？那样的话一次一次敲键盘会很麻烦。所以不妨把所有的操作都记录到一个文档中，然后去调用文档中的命令，这样一步操作就可以完成。其实这个文档呢就是shell脚本了，只是这个shell脚本有它特殊的格式。

凡是自定义的脚本建议放到/usr/local/sbin/目录下

* echo: 输出
* env: 列出系统的全部环境变量
* set : 列出系统的全部变量
* date: 显示当前系统的时间
* $PATH：这个环境变量就是shell预设的一个变量，通常shell预设的变量都是大写的。变量，说简单点就是使用一个较简单的字符串来替代某些具有特殊意义的设定以及数据。**就拿PATH来讲，这个PATH就代替了所有常用命令的绝对路径的设定。因为有了PATH这个变量，所以我们运行某个命令时不再去输入全局路径，直接敲命令名即可**,输入命令之后，系统就会去$PATH中所有的路径中去找有没有对应的命令可以执行，然后进行执行；
* export: 声明一个全局变量
* unset: 取消某个全局变量

我们在给 $PATH 常量赋值的时候，经常会有如下操作，最后的 $PATH其实是为了保留上次的值

[参考文档](http://www.92csz.com/study/linux/12.htm)

```java
export PATH="/usr/local/opt/php@7.1/bin:$PATH"
export PATH="/usr/local/opt/php@7.1/sbin:$PATH"
```

```javascript
export TESTPATH=123
echo $TESTPATH //123
export TESTPATH=456:$TESTPATH
echo $TESTPATH //456:123
```

然后输入 env,可以看到 TESTPATH这个全局变量；

```javascript
// ...
	//其他全局变量
TESTPATH=456:123
// ...
```

然后可以通过 unset 命令取消全局变量，unset TESTPATH

```javascript
//...
	//其他全局变量
//...
```

切换终端的命令

```javascript
chsh -s /bin/zsh  //bash 等
```

查看系统中所有的终端

```javascript
cat /etc/shells
```

输入如下

```javascript
/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
```

对于vscode如何设置终端默认为 zsh? 可以通过设置里面更改配置进行操作；

```javascript
"terminal.integrated.shell.osx": "/bin/bash",
"terminal.integrated.shell.linux": "/bin/bash",
```

```javascript
"terminal.integrated.shell.osx": "/bin/zsh",
"terminal.integrated.shell.linux": "/bin/zsh",
```



**.bash_profile** ：定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,**该文件仅仅执行一次**。

**.bashrc** ：该文件包含专用于你的shell的bash信息,**当登录时以及每次打开新的shell时,**该该文件被读取。例如你可以将用户自定义的alias或者自定义变量写到这个文件中。

**.bash_history** ：记录命令历史用的。

**.bash_logout** ：当退出shell时，会执行该文件。可以把一些清理的工作放到这个文件中。

 ### 3 文件操作&磁盘管理

* cat : 查看某个文件 -n 显示行号 -A 显示出所有东西，包括特殊字符；
* less  more tail head  文件名
* df   du  查看文件大小

### 4 文本编辑工具（vim)

一般模式 -  编辑模式  - 命令模式



### 5 [Linux命令详解](https://www.linuxdaxue.com/linux-commands-manual)

#### ls

```
-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为"."的视为隐藏档，不会列出) 

-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 

-r 将文件以相反次序显示(原定依英文字母次序) 

-t 将文件依建立时间之先后次序列出 

-A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录) 

-F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/" 

-R 若目录下有文件，则以下之文件亦皆依序列出

```

#### mkdir

```
-m, --mode=模式，设定权限<模式> (类似 chmod)，而不是 rwxrwxrwx 减 umask

-p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;

-v, --verbose  每次创建新目录都显示信息 mkdir -v test //提示信息如下：create directory test

    --help   显示此帮助信息并退出

    --version  输出版本信息并退出
```

#### tree  

##### tree -C : 看着比较舒服

```
-a 显示所有文件和目录。 

-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。 

-C 在文件和目录清单加上色彩，便于区分各种类型。 

-d 显示目录名称而非内容。 

-D 列出文件或目录的更改时间。 

-f 在每个文件或目录之前，显示完整的相对路径名称。 

-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。 

-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 

-i 不以阶梯状列出文件或目录名称。 

-I<范本样式> 不显示符合范本样式的文件或目录名称。 

-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 

-n 不在文件和目录清单加上色彩。 

-N 直接列出文件和目录名称，包括控制字符。 

-p 列出权限标示。 

-P<范本样式> 只显示符合范本样式的文件或目录名称。 

-q 用"?"号取代控制字符，列出文件和目录名称。 

-s 列出文件或目录大小。 

-t 用文件和目录的更改时间排序。 

-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 

-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。
```





